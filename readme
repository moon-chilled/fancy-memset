'fm' - 'fancy memset', a hopefully fast memset implementation
numbers are variable and depend heavily on sizes, but the sse2 version is:
20-150% faster than freebsd memset
300-500% faster than naive rep stos (e.g. musl, ~openbsd) on erms systems
5-100% faster than bionic memset[*], except for extremely small sizes (which do not really make for a fair comparison since the compiler will inline small constant memsets, and small nonconstant memsets are rare and not performance-critical)
(don't know about glibc, idk how to force it to use sse2)

avx2 version is:

300-400% faster than a naive loop compiled with -O3 by gcc/icc/clang
10-370% faster than glibc memset
20-370% faster than naive rep stos on erms systems (however this is hard to measure, as rep stos can use non-temporal stores, so the performance characteristics are broadly different)
50-470% faster than freebsd memset, for sizes larger than 64 bytes (see previous note about small/constant sizes)


try out the benchmark suite on your own system: 'make'
if you have an amd cpu or an older intel cpu, try: 'make erms='
on e.g. freebsd you may need to add 'AS=/usr/local/bin/as'

* this one is actually quite interesting.  On intel cpus, performance is only 5-30% better for small-med sizes.  Once sizes get quite large, though, fm performs 2x better because it takes advantage of erms.  On amd cpus, erms are not available, so performance for very large sizes is comparable (though fm still wins).  But performance for small-med sizes is much better for some reason.  So, 5-100% performance improvement is measurable on any cpu (except old intel chips, probably), but for different reasons and in different size classes.

todo compare against solaris/illumos memset: https://github.com/illumos/illumos-gate/blob/master/usr/src/lib/libc/amd64/gen/memset.s.  (Something that huge is obviously madness, but I do think that we can use jump tables to improve perf at small sizes.)
